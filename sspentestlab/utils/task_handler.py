"""
url: https://github.com/prompt-toolkit/python-prompt-toolkit/tree/master/examples/prompts/auto-completion
Demonstration of a custom completer class and the possibility of styling
completions independently by passing formatted text objects to the "display"
and "display_meta" arguments of "Completion".
"""
from prompt_toolkit.completion import Completer, Completion
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.shortcuts import CompleteStyle, prompt


class localTaskCompleter(Completer):
    tasks = [
        "discuss",  # discuss with pentestGPT on the local task
        "brainstorm",  # let pentestGPT brainstorm on the local task
        "continue",  # quit the local task  (for this local task)
    ]

    task_meta = {
        "discuss": HTML("Discuss with SSPentestLab about this local task."),
        "brainstorm": HTML("Let <b>SSPentestLab</b> brainstorm on the local task for all the possible solutions."),
        "continue": HTML("Quit the local task and continue the previous testing."),
    }


    def get_completions(self, document, complete_event):
        word = document.get_word_before_cursor()
        for task in self.tasks:
            if task.startswith(word):
                yield Completion(
                    task,
                    start_position=-len(word),
                    display=task,
                    display_meta=self.task_meta.get(task),
                )


class mainTaskCompleter(Completer):
    tasks = [
        "terminal",
        "next",
        "more",
        "todo",
        "discuss",
        "report",
        "help",
        "quit",
    ]

    task_meta = {
        "terminal": HTML("Terminal for your custom commands."),
        "next": HTML("Go to the next step."),
        "more": HTML("Discuss out of main to-do list."),
        "todo": HTML("Ask SSPentestLab for todos."),
        "discuss": HTML("Discuss with SSPentestLab."),
        "report": HTML("Generate a report."),
        "help": HTML("Show the help pge."),
        "quit": HTML("End the current session."),
    }

    task_details = """
[bold cyan]Available Task Commands and Subcommands:[/bold cyan]

[bold yellow]1. terminal:[/bold yellow]
    [green]•[/green] [bold]Launch an interactive terminal session[/bold] to manually execute shell commands. 
    This feature is designed for advanced users who require direct access to the command line for custom 
    operations or troubleshooting.

[bold yellow]2. next:[/bold yellow]
    [green]•[/green] [bold]Transition to the subsequent step[/bold] by submitting and processing the test results.
    This command includes several specialized subcommands:
    - Subcommands:
        [cyan]├── [bold]tool:[/bold][/cyan] [dim]Paste test results from various external tools or automated testing suites. 
            Supports multiple formats for seamless integration.[/dim]
        
        [cyan]├── [bold]user-comments:[/bold][/cyan] [dim]Custom text prompt where users can input any tool-specific 
            queries, observations, or additional instructions.[/dim]
        
        [cyan]├── [bold]read-last-command:[/bold][/cyan] [dim]Review the last executed command within the current tool session.
            This is particularly useful for verifying previous actions or diagnosing issues.[/dim]
        
        [cyan]├── [bold]read-history:[/bold][/cyan] [dim]Retrieve the full session history including all executed commands 
            and received outputs since the session's initiation.
            Useful for auditing or revisiting previous steps.[/dim]
        
        [cyan]└── [bold]web:[/bold][/cyan] [dim]Insert and embed web-based resources, such as documentation links, code snippets, 
            or external data relevant to the current task.[/dim]

[bold yellow]3. more:[/bold yellow]
    [green]•[/green] [bold]Ask about the previously issued task[/bold] or something non-related, its not going to have an impact on the main to-do tree.
    This command also includes several subcommands for enhanced functionality:
    - Subcommands:
        [cyan]├── [bold]discuss:[/bold][/cyan] [dim]Initiate an in-depth discussion regarding the question.
            This can include exploring alternative approaches, addressing potential issues, or clarifying ambiguities.[/dim]
        
        [cyan]├── [bold]brainstorm:[/bold][/cyan] [dim]Facilitate a structured brainstorming session to identify all viable 
            solutions or strategies for the current question. 
            Outputs a comprehensive list of ideas or methods.[/dim]
        
        [cyan]└── [bold]continue:[/bold][/cyan] [dim]Finish the current local session and resume the primary task sequence, 
            ensuring workflow continuity.[/dim]

[bold yellow]4. todo:[/bold yellow]
    [green]•[/green] [bold]Request an updated task list[/bold] from SSPentestLab. 
    This command provides a hierarchical breakdown of pending tasks, including dependencies, priorities, and recommended next steps. 
    Useful for maintaining a structured approach to task management.

[bold yellow]5. discuss:[/bold yellow]
    [green]•[/green] [bold]Engage in a dialog with the tool[/bold] to seek assistance, clarify task details, provide feedback, or discuss any aspect of the current workflow. 
    This is a versatile command for interactive problem-solving or guidance.

[bold yellow]6. report:[/bold yellow]
    [green]•[/green] [bold]Generate a comprehensive report[/bold] based on the collected data, test results, and session history. 
    The report is using a predifined template.

[bold yellow]7. help:[/bold yellow]
    [green]•[/green] [bold]Display this help documentation,[/bold] outlining all available commands and their subcommands. 
    Provides technical explanations for each command, ensuring users have the necessary guidance to utilize the tool effectively.

[bold yellow]8. quit:[/bold yellow]
    [green]•[/green] [bold]End the current session[/bold] and terminate all ongoing processes. 
    This command ensures that all session data is saved or archived as needed before exiting, preventing data loss and ensuring a clean shutdown.
"""


    def get_completions(self, document, complete_event):
        word = document.get_word_before_cursor()
        for task in self.tasks:
            if task.startswith(word):
                yield Completion(
                    task,
                    start_position=-len(word),
                    display=task,
                    display_meta=self.task_meta.get(task),
                )



def main_task_entry(text="> "):
    """Entry point for the task prompt. Auto-complete."""
    
    task_completer = mainTaskCompleter()
    while True:
        result = prompt(text, completer=task_completer)
        if result not in task_completer.tasks:
            print("Invalid task, try again.")
        else:
            return result



def local_task_entry(text="> "):
    """Entry point for the task prompt. Auto-complete."""
    
    task_completer = localTaskCompleter()
    while True:
        result = prompt(text, completer=task_completer)
        if result not in task_completer.tasks:
            print("Invalid task, try again.")
        else:
            return result



if __name__ == "__main__":
    main_task_entry()
