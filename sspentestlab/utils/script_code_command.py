import subprocess
import re
import json
import os
import time
 
def execute_command(command):
    """Executes commands and returns result."""
    
    try:
        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout = result.stdout.decode('utf-8')
        stderr = result.stderr.decode('utf-8')       
        return stdout, stderr
    except subprocess.CalledProcessError as e:
        return None, str(e)



def extract_commands(text):
    """Extracts commands coming from GPT answers labeled with <c>...</c>."""
    
    commands = re.findall(r'<c>([\s\S]*?)<\/c>', text)  
    result = [command.strip().replace('\n', ' ') for command in commands]
    # remove duplicates by converting to a set, then back to a list.
    result = list(set(result))
    return result


 
def extract_terminal(text):
    """Extracts commands coming from user input labeled with <term>...</term>."""
    
    commands = re.findall(r'<term>([\s\S]*?)<\/term>', text)  
    result = [command.strip().replace('\n', ' ') for command in commands]
    return result
 
 
 
def save_results_to_file(command, results, filename):
    """Save results to TXT."""
    
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, "w") as file:
        file.write(results)
 
 
 
def save_results_to_json(command, result, filename):
    """Save results to JSON."""
    command_id = time.strftime("%Y%m%d-%H%M%S")
    command_entry = {
        "command_id": command_id,
        "command": command,
        "result": result
    }
 
    if os.path.exists(filename):
        with open(filename, "r") as file:
            data = json.load(file)
    else:
        data = []
 
    data.append(command_entry)
 
    with open(filename, "w") as file:
        json.dump(data, file, indent=4)



def analyze_text(texto, json_unico):
    """Analyze text input to detect labels inside."""
    respuestagpt = texto
 
    # extract commands
    commands = extract_commands(respuestagpt)
    comandos_terminal = extract_terminal(respuestagpt)
    results = ""
    # execute and save the result from commands coming from terminal
    if comandos_terminal:
        for commando_t in comandos_terminal:
            # special handling for 'ping' command
            if commando_t.startswith("ping"):
                commando_t = f"{commando_t} -c 4"  # send 4 packets instead of running indefinitely
           
            stdout, stderr = execute_command(commando_t)
            print(f"Executing command: {commando_t}")
            print("")
            print(" - - - - - - - - ")
            if stdout:
                print(f"Command result: '{commando_t}':\n{stdout}")
                results += f"Command result: '{commando_t}':\n{stdout}\n"
            if stderr:
                print(f"Error while executing the command: '{commando_t}':\n{stderr}")
                results += f"Error while executing the command: '{commando_t}':\n{stderr}\n"
            # save the last result into a TXT
            save_results_to_file(commando_t, results, "./logs/commands/result.txt")
           
            # save the last result into a JSON
            save_results_to_json(commando_t, results, f"./logs/commands/{json_unico}")
               
    # save commands coming from user input and labeled with <code>
    if commands:
        for command in commands:
            print("")
            execute = input(f"Â¿Would you like to execute the command: '{command}'? (y/N/c): ")
            if execute.lower() == 'y':
                stdout, stderr = execute_command(command)
                print(f"Executing command: {command}")
                print("")
                print(" - - - - - - - - ")
                if stdout:
                    print(f"Command result: '{command}':\n{stdout}")
                    results += f"Command result: '{command}':\n{stdout}\n"
                if stderr:
                    print(f"Ersror while executing the command: '{command}':\n{stderr}")
                    results += f"Error while executing the command: '{command}':\n{stderr}\n"
                # save the last result into a TXT
                save_results_to_file(command, results, "./logs/commands/result.txt")
            
                # save the last result into a JSON
                save_results_to_json(command, results, f"./logs/commands/{json_unico}")
            if execute.lower() == 'c':
                break

if __name__ == "__main__":
    analyze_text()